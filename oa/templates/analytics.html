{% extends "base.html" %}


{% block title %}Analytics{% endblock %}

{% block extra_head %}

<style>
    .custom-popover {
      --bs-popover-max-width: 400px;
    }
</style>

{% endblock %}

{% block content %}

    <div class="container mt-4 mb-4">

        <!-- Assistants Table -->
        <div id="assistants-container" class="my-4">

            <h5 class="my-3">Assistant usage overview</h5>

            {% include 'partials/loading_indicator.html' with content_id='assistants' content_name='assistants' %}

            <div class="row">

                <div class="col-3">
                    <ul class="nav nav-pills flex-column" role="tablist" id="assistantTabs">
                    </ul>
                </div>

                <div class="col-9">
                    <div class="tab-content" id="assistantContent">
                    </div>
                </div>

            </div>

            <div id="no-assistants" class="text-center text-secondary d-none">
                <p>No assistants available.</p>
                <span class="text-secondary">
                    You can create assistants <a href="{% url "manage_assistants" project_uuid=selected_project.uuid %}" class="text-decoration-none">here</a>.
                </span>
            </div>

        </div>

    </div>

{% endblock %}

{% block extra_scripts %}
<script>

    const API_KEY = "{{ selected_project.uuid }}";

    /* Utility functions */

    function initializePopovers() {
        const popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
        popoverTriggerList.map(function (popoverTriggerEl) {
            return new bootstrap.Popover(popoverTriggerEl);
        });
    }

    function formatDbDate(dateString) {
        if (!dateString) return '<span class="text-secondary">No threads</span>';
        const date = new Date(dateString);
        // Extract day, month, year, hours, and minutes
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');

        return `${day}/${month}/${year}, ${hours}:${minutes}`;
    }

    function formatUnixTimestamp(unixTimestamp) {
        const date = new Date(unixTimestamp * 1000); // Convert seconds to milliseconds
        const day = String(date.getDate()).padStart(2, '0'); // Ensure 2 digits for the day
        const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, '0'); // 24-hour format
        const minutes = String(date.getMinutes()).padStart(2, '0');

        return `${day}/${month}/${year}, ${hours}:${minutes}`;
    }

    function formatExpireTime(expireString) {
        let icon = '';

        if (expireString === 'Expired') {
            icon = '<i class="bi bi-exclamation-circle text-danger"></i> ';
        } else {
            const parts = expireString.split(' ');
            if (parts.length === 2) {
                const unit = parts[1]; // yrs, mos, days, hrs, mins, secs

                const soonUnits = ['hrs', 'mins', 'secs'];
                if (soonUnits.includes(unit)) {
                    icon = ' <i class="bi bi-exclamation-triangle text-warning"></i> ';
                }
            }
        }

        return icon + expireString;
    }


    /* Globals */

    let vectorStoresDict = {}; // vectorStoreId -> vectorStoreName
    let assistantsDict = {}; // assistantId -> assistantName
    let threadsDict = {}; // threadId -> thread data


    /* Assistants */

    async function fetchAssistants() {
        try {
            const assistantsResponse = await fetch("{% url 'api-1.0.0:list_assistants' %}", {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${API_KEY}`,
                    'Content-Type': 'application/json',
                }
            });

            const assistantsData = await assistantsResponse.json();

            console.log('assistants:', assistantsData);

            populateTabsAndContent(assistantsData.assistants);

        } catch (error) {
            console.error('Error fetching assistants:', error);
        } finally {
            toggleLoading('assistants', false);
        }
    }

    function populateTabsAndContent(assistants) {
        // Get references to the tabs and content containers
        const tabsContainer = document.getElementById('assistantTabs');
        const contentContainer = document.getElementById('assistantContent');

        // Clear existing content
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = '';

        // Populate tabs and contents
        assistants.forEach((assistant, index) => {
            // Create a tab item
            const tabItem = document.createElement('li');
            tabItem.className = 'nav-item';

            const tabLink = document.createElement('a');
            tabLink.className = `nav-link ${index === 0 ? 'active' : ''}`;
            tabLink.setAttribute('data-bs-toggle', 'tab');
            tabLink.setAttribute('href', `#assistant-${assistant.id}`);
            tabLink.setAttribute('role', 'tab');
            tabLink.setAttribute('aria-controls', `assistant-${assistant.id}`);
            tabLink.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
            tabLink.textContent = assistant.name || 'Unnamed Assistant';

            tabItem.appendChild(tabLink);
            tabsContainer.appendChild(tabItem);

            // Create a content pane
            const contentPane = document.createElement('div');
            contentPane.className = `tab-pane fade ${index === 0 ? 'show active' : ''}`;
            contentPane.setAttribute('id', `assistant-${assistant.id}`);
            contentPane.setAttribute('role', 'tabpanel');
            contentPane.setAttribute('aria-labelledby', `assistant-${assistant.id}-tab`);

            // Populate content pane with assistant details
            contentPane.innerHTML = `
                <h4>${assistant.name || 'Unnamed Assistant'}</h4>
                <p><strong>Model:</strong> ${assistant.model}</p>
                <p><strong>Tools:</strong> ${assistant.tools.map(tool => tool.type).join(', ') || 'None'}</p>
                <div id="stats-${assistant.id}"></div>
            `;

            contentContainer.appendChild(contentPane);

            // Fetch and display cumulative token usage stats
            fetchTokenUsageStats(assistant.id);
        });
    }

    async function fetchTokenUsageStats(assistantId) {

        const listThreadsUrlTemplate = "{% url 'api-1.0.0:list_threads' assistant_id='ASSISTANT_ID_PLACEHOLDER' %}";
        const url = listThreadsUrlTemplate.replace('ASSISTANT_ID_PLACEHOLDER', assistantId);


        try {
            // Fetch thread IDs for the assistant
            const threadsResponse = await fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${API_KEY}`,
                    'Content-Type': 'application/json',
                }
            });
            const threadsData = await threadsResponse.json();

            const threadIds = threadsData['thread_ids'];

            if (threadIds.length === 0) {
                document.getElementById(`stats-${assistantId}`).innerHTML = `<strong>No threads found for this assistant.</strong>`;
                return;
            }

            let cumulativeStats = {
                prompt_tokens: 0,
                completion_tokens: 0,
                total_tokens: 0
            };

            let threadCreationDates = [];
            let totalThreads = threadsData.length;

            for (const threadId of threadIds) {

                const listRunsUrlTemplate = "{% url 'api-1.0.0:list_runs' thread_id='THREAD_ID_PLACEHOLDER' %}";
                const url = listRunsUrlTemplate.replace('THREAD_ID_PLACEHOLDER', threadId);

                // Fetch runs for the thread
                const runsResponse = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json',
                    }
                });
                const runsData = await runsResponse.json();

                // Aggregate token usage stats
                for (const run of runsData.runs) {
                    cumulativeStats.prompt_tokens += run.usage.prompt_tokens;
                    cumulativeStats.completion_tokens += run.usage.completion_tokens;
                    cumulativeStats.total_tokens += run.usage.total_tokens;
                }
            }

            // Update the stats in the content pane
            document.getElementById(`stats-${assistantId}`).innerHTML = `
                <p><strong>Cumulative Token Usage:</strong></p>
                <ul>
                    <li>Prompt Tokens: ${cumulativeStats.prompt_tokens}</li>
                    <li>Completion Tokens: ${cumulativeStats.completion_tokens}</li>
                    <li>Total Tokens: ${cumulativeStats.total_tokens}</li>
                </ul>
            `;
        } catch (error) {
            console.error(`Error fetching token usage stats for assistant ${assistantId}:`, error);
            document.getElementById(`stats-${assistantId}`).innerHTML = `<strong>Error loading token usage stats.</strong>`;
        }
    }


    /* Threads */

    async function fetchThreadsData(assistantIds) {
        try {
            const response = await fetch("{% url 'get_assistant_threads' %}", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": '{{ csrf_token }}'
                },
                body: JSON.stringify({ assistant_ids: assistantIds }),
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch threads: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching thread counts:', error);
            return {};
        }
    }

    async function fetchThreadsTable(assistantIds) {
        try {
            const response = await fetch("{% url 'list_threads' %}", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": '{{ csrf_token }}'
                },
                body: JSON.stringify({ assistant_ids: assistantIds }),
            });
            const data = await response.json();

            console.log('fetchThreadsTable:', data);

            if (data.threads?.length > 0) {
                // We'll fetch usage for each thread in parallel.
                const usagePromises = data.threads.map(async (thread) => {
                    let totalTokens = 0;

                    const listRunsUrlTemplate = "{% url 'api-1.0.0:list_runs' thread_id='THREAD_ID_PLACEHOLDER' %}";
                    const url = listRunsUrlTemplate.replace('THREAD_ID_PLACEHOLDER', thread.id);
                    try {
                        const runsResp = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${API_KEY}`,
                                'Content-Type': 'application/json',
                                "X-CSRFToken": '{{ csrf_token }}'
                            }
                        });
                        const runsData = await runsResp.json();

                        console.log('runsData', runsData);

                        if (runsData.runs && Array.isArray(runsData.runs)) {
                            // Process runs asynchronously
                            const tokenPromises = runsData.runs.map(async (run) => {
                                console.log('run model:', run.model);
                                if (run.usage?.total_tokens) {
                                    return run.usage.total_tokens;
                                }
                                return 0;
                            });

                            const tokenResults = await Promise.all(tokenPromises);
                            totalTokens = tokenResults.reduce((sum, tokens) => sum + tokens, 0);
                        }
                    } catch (error) {
                        console.error(`Error fetching runs for thread ${thread.id}:`, error);
                    }
                    return totalTokens;
                });

                // Wait for all usagePromises to resolve
                const usageResults = await Promise.all(usagePromises);

                // Attach usage to each thread
                data.threads.forEach((thread, idx) => {
                    thread.usage = usageResults[idx];
                });

                // Now build the table rows
                const tableBody = document.getElementById('threads-table-body');
                tableBody.innerHTML = '';

                const rows = data.threads.map(thread => {
                    const created = formatUnixTimestamp(thread.created_at);
                    const asstName = assistantsDict[thread.assistant_id] || '<span class="text-secondary">Unknown</span>';
                    let sharedDisplay = '<span class="text-secondary">No</span>';
                    if (thread.shared_link_name) {
                        sharedDisplay = `<span class="text-success">${thread.shared_link_name}</span>`;
                    }

                    return `
                        <tr>
                            <td>${thread.id}</td>
                            <td>${created}</td>
                            <td>${asstName}</td>
                            <td>${sharedDisplay}</td>
                            <td>${thread.usage || 0}</td>
                        </tr>
                    `;
                });

                tableBody.innerHTML = rows.join('');
                document.getElementById('threads-table').classList.remove('d-none');
            } else {
                document.getElementById('no-threads').classList.remove('d-none');
            }
        } catch (error) {
            console.error('Error fetching threads:', error);
        } finally {
            toggleLoading('threads', false);
        }
    }


    /* Initialize Page */

    async function initializePage() {
        // Show loading indicator initially for all
        toggleLoading('assistants', true);
        toggleLoading('threads', true);

        fetchAssistants();
    }

    initializePage()

</script>

{% include "partials/utils_js.html" %}

{% endblock %}
